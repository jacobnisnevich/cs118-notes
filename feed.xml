<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS 118 Notes</title>
    <description></description>
    <link>http://jacobnisnevich.github.io/cs118-notes/</link>
    <atom:link href="http://jacobnisnevich.github.io/cs118-notes/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 31 Mar 2016 21:25:46 -0700</pubDate>
    <lastBuildDate>Thu, 31 Mar 2016 21:25:46 -0700</lastBuildDate>
    <generator>Jekyll v3.0.3</generator>
    
      <item>
        <title>Lecture 2</title>
        <description>&lt;h3 id=&quot;covered-in-lecture-1&quot;&gt;Covered in Lecture 1&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Internet: made of a huge number of hosts and routers, interconnected by physical and wireless links&lt;/li&gt;
  &lt;li&gt;Hosts: run bunch of protocols to exchange data with each other&lt;/li&gt;
  &lt;li&gt;Routers: run bunch of protocols to exchange data with each other&lt;/li&gt;
  &lt;li&gt;Protocols are organized in layers
    &lt;ul&gt;
      &lt;li&gt;Application protocols&lt;/li&gt;
      &lt;li&gt;Transport protocols&lt;/li&gt;
      &lt;li&gt;Network protocols&lt;/li&gt;
      &lt;li&gt;Link layer protocols&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;How to calculate packet delays as they move across a network&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;data-delivery-performance&quot;&gt;Data Delivery Performance&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;3 basic measurements
    &lt;ul&gt;
      &lt;li&gt;Delay (sec, msec)&lt;/li&gt;
      &lt;li&gt;Throughput (bits/sec, Kbps, Mbps, Gbps)&lt;/li&gt;
      &lt;li&gt;Loss rate (% of packets that did not make it)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Transmission delay: L / R
    &lt;ul&gt;
      &lt;li&gt;R = link bandwidth (bps)&lt;/li&gt;
      &lt;li&gt;L = packet length (bits)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Propagation: d / s
    &lt;ul&gt;
      &lt;li&gt;d = length of physical link&lt;/li&gt;
      &lt;li&gt;s = propagation speed in medium (~2 x 10^8 m/sec)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Queueing delay = # packets in queue x transmission time of each packet&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lets-try-an-example&quot;&gt;Lets Try an Example&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;A&lt;/strong&gt; —- R —-&amp;gt; &lt;strong&gt;S1&lt;/strong&gt; ——– 2R ——–&amp;gt; &lt;strong&gt;S2&lt;/strong&gt; —- R —-&amp;gt; &lt;strong&gt;B&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;L = 4000 bits, R = 2 Mbps, A sends 4 packets
    &lt;ul&gt;
      &lt;li&gt;L / R = 2 ms, L / 2R = 1 ms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Propagation delay: 2 ms for each link&lt;/li&gt;
  &lt;li&gt;When will the first packet get to S2?
    &lt;ul&gt;
      &lt;li&gt;A – S1: D_transmission + D_propagation = 2 ms + 2 ms&lt;/li&gt;
      &lt;li&gt;S1 – S2: D_transmission + D_propagation = 1 ms + 2 ms = 3 ms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When the first packet arrives at S2, where is the second packet?
    &lt;ul&gt;
      &lt;li&gt;This occurs at t = 7 ms&lt;/li&gt;
      &lt;li&gt;At t = 4 ms, last bit leaves A&lt;/li&gt;
      &lt;li&gt;At t = 6 ms, last bit arrives at S1&lt;/li&gt;
      &lt;li&gt;At t = 7 ms, last bit leaves S1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a-summary-where-is-the-packet&quot;&gt;A summary: Where is the Packet?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A ————&amp;gt; B
    &lt;ul&gt;
      &lt;li&gt;Bandwidth: W,&lt;/li&gt;
      &lt;li&gt;Link length: 200 km&lt;/li&gt;
      &lt;li&gt;Packet size: 1000 bits&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Q: when the first bit of the packet reaches B, where is the last bit?
    &lt;ul&gt;
      &lt;li&gt;P = propagation delay = 200,000 m / 2 x 10^8 m/sec = 1 ms&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If transmission delay = P (W = 1 Mbps)&lt;/li&gt;
  &lt;li&gt;If transmission delay = 0.1 P
    &lt;ul&gt;
      &lt;li&gt;bandiwdth * propagation delay = amount of data in the pipe&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chapter-2-application-layer&quot;&gt;Chapter 2: Application Layer&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Principles of network applications&lt;/li&gt;
  &lt;li&gt;Web and HTTP&lt;/li&gt;
  &lt;li&gt;FTP&lt;/li&gt;
  &lt;li&gt;Electronic Mail&lt;/li&gt;
  &lt;li&gt;DNS&lt;/li&gt;
  &lt;li&gt;P2P applications&lt;/li&gt;
  &lt;li&gt;Socket programming (covered in section)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;some-population-network-applications&quot;&gt;Some Population Network Applications&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Email&lt;/li&gt;
  &lt;li&gt;Web&lt;/li&gt;
  &lt;li&gt;Instant messaging&lt;/li&gt;
  &lt;li&gt;P2P file sharing&lt;/li&gt;
  &lt;li&gt;Multi-user network games&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;client-server-application-communication-model&quot;&gt;Client-server application communication model&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Servers&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;Reachable by IP address&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Always-on&lt;/strong&gt;, &lt;em&gt;waiting&lt;/em&gt; for incoming requests from clients&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Clients&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;Initiate&lt;/em&gt; communication with server&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Q: How does a client process &lt;strong&gt;identify&lt;/strong&gt; the server process with which it wants to communicate?&lt;/li&gt;
  &lt;li&gt;A: using port numbers via the socket API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a-quick-comment-about-port&quot;&gt;A quick comment about “port”&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web, email, ftp all use TCP&lt;/li&gt;
  &lt;li&gt;How does the server tell who wants what?
    &lt;ul&gt;
      &lt;li&gt;By port number: web uses port 80, ftp uses 21, and email uses 25&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;socket&quot;&gt;Socket&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Process&lt;/strong&gt;: program running on a host&lt;/li&gt;
  &lt;li&gt;Between different hosts: processes communcate through an &lt;strong&gt;application-layer protocol&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;A process sends/receives messages to/from its &lt;strong&gt;socket&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Socket analogous to door:
    &lt;ul&gt;
      &lt;li&gt;Sending process shoves message out of the door&lt;/li&gt;
      &lt;li&gt;Transport protocol brings message up to the socket from the process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-is-socket&quot;&gt;What is “Socket”&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A set of system function calls
    &lt;ul&gt;
      &lt;li&gt;socket() - create a socket&lt;/li&gt;
      &lt;li&gt;bind() - bind a socket to a local IP address and port #&lt;/li&gt;
      &lt;li&gt;connect() - initiating connection to another socket&lt;/li&gt;
      &lt;li&gt;listen() - passively waiting for connections&lt;/li&gt;
      &lt;li&gt;accept() - accept a new connection&lt;/li&gt;
      &lt;li&gt;write() - write data to a socket&lt;/li&gt;
      &lt;li&gt;read() - read data from a socket&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;establishing-a-socket-on-the-client-side&quot;&gt;Establishing a socket on the client side&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Create a socket with the socket() system call&lt;/li&gt;
  &lt;li&gt;Connect the socket to the server using the connect() system call&lt;/li&gt;
  &lt;li&gt;Send and receive data
    &lt;ul&gt;
      &lt;li&gt;There are a number of ways to do this, but the simplest is to use the read() and write() system calls&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;establishing-a-socket-on-the-server-side&quot;&gt;Establishing a socket on the server side&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Create a socket with the socket() system call&lt;/li&gt;
  &lt;li&gt;Bind the socket to [address, port #] using the bind() system call&lt;/li&gt;
  &lt;li&gt;Listen for connections with the listen() system call&lt;/li&gt;
  &lt;li&gt;Accept a connection with the accept() system call
    &lt;ul&gt;
      &lt;li&gt;This call typically blocks until a client connects with the server&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Send and receive data&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;applications&quot;&gt;Applications&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;So far we’ve talked about
    &lt;ul&gt;
      &lt;li&gt;Application process (executing application program)&lt;/li&gt;
      &lt;li&gt;Application protocol (used by application processes to exchange data)&lt;/li&gt;
      &lt;li&gt;Exactly how data is exchanged
        &lt;ul&gt;
          &lt;li&gt;Socket&lt;/li&gt;
          &lt;li&gt;Transport protocol&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Lets look at exactly what data is exchanged&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;web-and-http&quot;&gt;Web and HTTP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web page: normally consists of
    &lt;ul&gt;
      &lt;li&gt;Base HTML-file, which includes several referenced objects&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;An object can be another HTML file, JPEG image, Java applet, audio file, …&lt;/li&gt;
  &lt;li&gt;Each object is addressable by a URL (Universal Resource Locator)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-hypertext-transfer-protocol&quot;&gt;HTTP: HyperText Transfer Protocol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web’s application layer protocol&lt;/li&gt;
  &lt;li&gt;Client/server model
    &lt;ul&gt;
      &lt;li&gt;Client: browser that requests, recieves, and displays web objects&lt;/li&gt;
      &lt;li&gt;Server: web server sends objects in response to requests&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP/1.0: non-persistent connection&lt;/li&gt;
  &lt;li&gt;HTTP/1.1: persistent connection
    &lt;ul&gt;
      &lt;li&gt;May also use pipelining&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;more-on-http&quot;&gt;More on HTTP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Uses TCP:
    &lt;ul&gt;
      &lt;li&gt;Client initiates TCP connection (creates socket) to server, port 80&lt;/li&gt;
      &lt;li&gt;Server accepts TCP connection from client&lt;/li&gt;
      &lt;li&gt;HTTP messages (application-layer protocol messages) exhanged between browser (HTTP client) and web server (HTTP server)&lt;/li&gt;
      &lt;li&gt;TCP connection closed&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP is “stateless”
    &lt;ul&gt;
      &lt;li&gt;Server maintains no information about past client requests&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Aside: protocols that maintain “state” are complext
    &lt;ul&gt;
      &lt;li&gt;Past history (state) must be maintained if server/client crashes, their views of “state” may become inconsistent&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-request-message&quot;&gt;HTTP Request MEssage&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Two types of HTTP messages: request, response&lt;/li&gt;
  &lt;li&gt;HTTP request message:
    &lt;ul&gt;
      &lt;li&gt;ASCII (human-readable)&lt;/li&gt;
      &lt;li&gt;Request line: method, url, veresion, \r, \n
        &lt;ul&gt;
          &lt;li&gt;“GET /index.html HTTP/1.1\r\n”&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Header lines&lt;/li&gt;
      &lt;li&gt;Blank line at the end indicates end of header&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;method-types&quot;&gt;Method Types&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP/1.0
    &lt;ul&gt;
      &lt;li&gt;GET&lt;/li&gt;
      &lt;li&gt;POST&lt;/li&gt;
      &lt;li&gt;HEAD
        &lt;ul&gt;
          &lt;li&gt;Requesting the header only (i.e. response does not include the requested object)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP/1.1
    &lt;ul&gt;
      &lt;li&gt;GET, POST, HEAD&lt;/li&gt;
      &lt;li&gt;PUT
        &lt;ul&gt;
          &lt;li&gt;Uploads file in entity body to path specified in URL field&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DELETE
        &lt;ul&gt;
          &lt;li&gt;Deletes file specifie in the URL field from the server&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;And a few others
        &lt;ul&gt;
          &lt;li&gt;See te protocol specification in RFC2616&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-response-message&quot;&gt;HTTP Response Message&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Status line
    &lt;ul&gt;
      &lt;li&gt;“HTTP/1.1 200 OK\r\n”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Header lines&lt;/li&gt;
  &lt;li&gt;Blank line indicating end of header&lt;/li&gt;
  &lt;li&gt;Data, e.g., requested HTML file&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-response-status-codes&quot;&gt;HTTP Response Status Codes&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Appears in the first line in server -&amp;gt; clinet response message&lt;/li&gt;
  &lt;li&gt;A few sample codes
    &lt;ul&gt;
      &lt;li&gt;200 OK
        &lt;ul&gt;
          &lt;li&gt;Request succeeded, requested object later in this message&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;301 Moved Permanently
        &lt;ul&gt;
          &lt;li&gt;Requested object moved&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;400 Bad Request&lt;/li&gt;
      &lt;li&gt;404 Not Found
        &lt;ul&gt;
          &lt;li&gt;Requested document not found&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;505 HTTP Version Not Supported&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;trying-out-http-request-for-yourself&quot;&gt;Trying out HTTP Request for Yourself&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Telnet to a Web server&lt;/li&gt;
  &lt;li&gt;Type in a GET HTTP request&lt;/li&gt;
  &lt;li&gt;Look at response message from the HTTP server&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 31 Mar 2016 20:53:00 -0700</pubDate>
        <link>http://jacobnisnevich.github.io/cs118-notes/2016/03/31/lecture_2.html</link>
        <guid isPermaLink="true">http://jacobnisnevich.github.io/cs118-notes/2016/03/31/lecture_2.html</guid>
        
        
      </item>
    
      <item>
        <title>Lecture 1</title>
        <description>&lt;h3 id=&quot;what-is-a-computer-network&quot;&gt;What is a computer network?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;IP protocol, etc&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cs-118-explain-to-you-how-internet-works&quot;&gt;CS 118: Explain to you how internet works&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Divide-and-conquer
    &lt;ul&gt;
      &lt;li&gt;Internet: a very large and complex system&lt;/li&gt;
      &lt;li&gt;First: figure out many major parts&lt;/li&gt;
      &lt;li&gt;Then: learn one part at a time&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Your job:
    &lt;ul&gt;
      &lt;li&gt;Read the textbook, think through&lt;/li&gt;
      &lt;li&gt;Ask questions&lt;/li&gt;
      &lt;li&gt;Practice from doing your homeworks and projects&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;course-workload&quot;&gt;Course Workload&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Weekly reading assigmments (starting today)&lt;/li&gt;
  &lt;li&gt;Weekly homework assignments
    &lt;ul&gt;
      &lt;li&gt;Available from CCLE every Thursady starting this week, due the following
Wednesday&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Two programming Projects
    &lt;ul&gt;
      &lt;li&gt;Work in a team (up to 3 people in each time)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Midterm: Thursday, April 28 (in class)&lt;/li&gt;
  &lt;li&gt;Final: Monday, June 6, 2016, 6:30pm - 9:30pm&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;course-grading&quot;&gt;Course Grading&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;16% Weekly homework assigments (8 total)&lt;/li&gt;
  &lt;li&gt;40% for 2 programming projects
    &lt;ul&gt;
      &lt;li&gt;1st: 20%, 2nd 20%&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;22% Midterm exam&lt;/li&gt;
  &lt;li&gt;22% Final exam&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;strict-grading-policy&quot;&gt;Strict Grading Policy&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;No credit for late homework or projects&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;first-step-big-picture--terminology&quot;&gt;First step: Big Picture &amp;amp; Terminology&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Millions of connected computing devices
    &lt;ul&gt;
      &lt;li&gt;hosts = end systems&lt;/li&gt;
      &lt;li&gt;running network apps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Communication links
    &lt;ul&gt;
      &lt;li&gt;fiber, copper, radio, satellite&lt;/li&gt;
      &lt;li&gt;transmission rate: &lt;em&gt;bandiwdth&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Packet switches: forward packets (chunks of data)
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;routers&lt;/em&gt; and &lt;em&gt;switches&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nuts-and-bolts-view&quot;&gt;“Nuts and Bolts” view&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Internet: “network of networks”
    &lt;ul&gt;
      &lt;li&gt;Interconnected ISPs&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Protocols control sending, receiving of msgs
    &lt;ul&gt;
      &lt;li&gt;e.g., TCP, IP, HTTP, Skype, 802.11&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Internet standards
    &lt;ul&gt;
      &lt;li&gt;RFC: request for comments&lt;/li&gt;
      &lt;li&gt;IETF: Internet Engineering Task Force&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;applications-view-of-networking&quot;&gt;Application’s View of Networking&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web browser &amp;lt;——- Internet ——-&amp;gt; Web server&lt;/li&gt;
  &lt;li&gt;These are application programms&lt;/li&gt;
  &lt;li&gt;They talk to each other using application protocols (for web, protocol = HTTP)&lt;/li&gt;
  &lt;li&gt;Don’t know or care how data is sent; do care whether it is delivered reliably&lt;/li&gt;
  &lt;li&gt;Runs on top of transport protocols&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;whats-a-protocol&quot;&gt;What’s a Protocol&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Human protocols&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;“what’s the time”&lt;/li&gt;
      &lt;li&gt;“I have a question”&lt;/li&gt;
      &lt;li&gt;introductions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Network protocols&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;Machines rather than humans&lt;/li&gt;
      &lt;li&gt;All communication activity in Internet govered by protocols&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Protocols define format, order of messages sent and received among network entities, and actions taken on message transmission, receipt&lt;/li&gt;
  &lt;li&gt;… specific messages sent&lt;/li&gt;
  &lt;li&gt;… specific actions taken when messages received or other events&lt;/li&gt;
  &lt;li&gt;Network protocol
    &lt;ul&gt;
      &lt;li&gt;TCP connection request –&amp;gt; TCP connection response –&amp;gt; GET http://www.google.com –&amp;gt; &lt;file&gt; --&amp;gt;&lt;/file&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;application-layer-protocols&quot;&gt;Application Layer Protocols&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Covered in chapter 2 of the book&lt;/li&gt;
  &lt;li&gt;Basic objective: understand common application protocols:
    &lt;ul&gt;
      &lt;li&gt;Web: Hyper-Text Transfer Protocol (HTTP)&lt;/li&gt;
      &lt;li&gt;Email: Simple Mail Transport Protocol (SMTP)&lt;/li&gt;
      &lt;li&gt;Domain Name System (DNS)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;More important objective: design issues
    &lt;ul&gt;
      &lt;li&gt;What kinds of services required from the network&lt;/li&gt;
      &lt;li&gt;How does the choice of services impact application design?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;transport-view-of-networking&quot;&gt;Transport View of Networking&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Assuming &lt;strong&gt;application protocols&lt;/strong&gt; take care of &lt;strong&gt;data content&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Transport protocol’s job: delivering data between communicating ends&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Don’t know or care bout which paths data may traverse through the network&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Do care about:
    &lt;ol&gt;
      &lt;li&gt;Delivering data to the right application process&lt;/li&gt;
      &lt;li&gt;Delivery reliability&lt;/li&gt;
      &lt;li&gt;Congestion control&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;transport-layer-protocols&quot;&gt;Transport Layer Protocols&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Unreliable data delivery: UDP (User Datagram Protocol)&lt;/li&gt;
  &lt;li&gt;Reliable data delivery: TCP (Transport Control Protocol)
    &lt;ul&gt;
      &lt;li&gt;Reliable delivery over potentially unreliable network&lt;/li&gt;
      &lt;li&gt;Understanding and managin network delays&lt;/li&gt;
      &lt;li&gt;Coping with congetstion&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;But transport protocols don’t really do the delivery&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;network-layers-view-of-the-picture&quot;&gt;Network Layer’s view of the picture&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Assuming higher layer protocols handle data content, reliability and congestionm&lt;/li&gt;
  &lt;li&gt;Network’s job: forward data from source to destination&lt;/li&gt;
  &lt;li&gt;Do care about: which way to forward data at each step?&lt;/li&gt;
  &lt;li&gt;Why is this hard?  &lt;strong&gt;Because the Internet is huge!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;internet-connectivity&quot;&gt;Internet Connectivity&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Consider the connection from laptop to CNN.com:
    &lt;ul&gt;
      &lt;li&gt;Wi-Fi -&amp;gt; campus backbone -&amp;gt; ISP -&amp;gt; other ISP -&amp;gt; CNN website&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Access Networks
    &lt;ul&gt;
      &lt;li&gt;Connect end system to local network&lt;/li&gt;
      &lt;li&gt;Some local network router connects to ISP router&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ISP interconnect with each other to form the Internet&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;network-layer-protocols&quot;&gt;Network Layer PRotocols&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Covered in Chapter 4 of the textbook&lt;/li&gt;
  &lt;li&gt;There are different types of networks
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Circuit&lt;/strong&gt;-switched versus &lt;strong&gt;packet&lt;/strong&gt;-switched&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Internet: packet-switched networks
    &lt;ul&gt;
      &lt;li&gt;Network layer provides best effort delivery of packets&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Don’t care exactly how a packet is delivered from one node to next
    &lt;ul&gt;
      &lt;li&gt;That’s the job for link layer protocls&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;link-layer-protocols&quot;&gt;Link layer protocols&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Link can be twisted pair, coaxial cable, fiber optic, or wireless&lt;/li&gt;
  &lt;li&gt;Link layer job: get a packet sent across some medium
    &lt;ul&gt;
      &lt;li&gt;Different medium -&amp;gt; different link layer protocol&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Covered in Chapter 5 and 6.1 - 6.3 of the text
    &lt;ul&gt;
      &lt;li&gt;Borders on Electrical Engineering: running on top of physical layer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Our objective is to understand technology
    &lt;ul&gt;
      &lt;li&gt;How the network is built&lt;/li&gt;
      &lt;li&gt;How do link layer features impact higher layers design&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;internet-protocol-stack&quot;&gt;Internet Protocol Stack&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Application layer&lt;/li&gt;
  &lt;li&gt;Transport layer&lt;/li&gt;
  &lt;li&gt;Network layer&lt;/li&gt;
  &lt;li&gt;Link layer&lt;/li&gt;
  &lt;li&gt;Physical layer&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;packet-switching-multiplexing-queuing-delay-loss&quot;&gt;Packet Switching: Multiplexing, Queuing Delay, Loss&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Queuing and loss:&lt;/li&gt;
  &lt;li&gt;If arrival rate (in bits) to link exceeds transmission rate of link for a period of time:
    &lt;ul&gt;
      &lt;li&gt;Packets will queue, wait to be transmitted on link&lt;/li&gt;
      &lt;li&gt;Packets can be dropped (lost) if memory (buffer) fills up&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;data-delivery-performance&quot;&gt;Data Delivery Performance&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;3 basic measurments
    &lt;ul&gt;
      &lt;li&gt;Delay (sec, msec)&lt;/li&gt;
      &lt;li&gt;Throughput (bits/sec)&lt;/li&gt;
      &lt;li&gt;Loss rate (% of packets lost)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Measure at different points -&amp;gt; different results&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;packet-losses&quot;&gt;Packet Losses&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Loss due to transmission errors&lt;/li&gt;
  &lt;li&gt;Loss due to congestion&lt;/li&gt;
  &lt;li&gt;Wireless links: variety of possible issues&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;throughput&quot;&gt;Throughput&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Throughput over a single link
    &lt;ul&gt;
      &lt;li&gt;Point-to-point
        &lt;ul&gt;
          &lt;li&gt;Pumping data to the pipe: link bandwidth&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Multi-access&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Throughput between two end hosts&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;delay-in-packet-switched-networks&quot;&gt;Delay in packet-switched networks&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;4 sources of delay at each hop
    &lt;ul&gt;
      &lt;li&gt;Nodal processing:
        &lt;ul&gt;
          &lt;li&gt;Check bit errors&lt;/li&gt;
          &lt;li&gt;Determine output link&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Queuing = ### packets in queue X transmission time of each packets&lt;/li&gt;
      &lt;li&gt;Transmission = L / R
        &lt;ul&gt;
          &lt;li&gt;L = packet length (bits)&lt;/li&gt;
          &lt;li&gt;R = link bandwidth (bps)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Propagation = d / s
        &lt;ul&gt;
          &lt;li&gt;d = length of physical link&lt;/li&gt;
          &lt;li&gt;s = propagation speed in medium&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;example-one-hop-delay&quot;&gt;Example: one hop delay&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Details:
    &lt;ul&gt;
      &lt;li&gt;link length = 100 km&lt;/li&gt;
      &lt;li&gt;bandwidth = 1 Mbps&lt;/li&gt;
      &lt;li&gt;packet size = 1000 bits&lt;/li&gt;
      &lt;li&gt;All packets equal length&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Queuing delay = Waiting time for 2 packets&lt;/li&gt;
  &lt;li&gt;Transmission delay = 1000 bits / 1000000 bits/sec = 0.001 sec = 1 msec&lt;/li&gt;
  &lt;li&gt;Propagation delay = 100000 m / 2 * 10^8 m/s = 0.0005 sec = 0.5 msec&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;packet-switching-store-and-forward&quot;&gt;Packet-switching: store-and-forward&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Takes L / R seconds to transmit packet of L bits on to link of R bps&lt;/li&gt;
  &lt;li&gt;Entire packet must arrive at router before it can be transmitted on next link: &lt;strong&gt;store and forward&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;network-latency&quot;&gt;Network Latency&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Time to send 1 packet from point A to point B
    &lt;ul&gt;
      &lt;li&gt;Sum of delays across each hop along the path&lt;/li&gt;
      &lt;li&gt;Delay_A-B = Delay_A-1 + Delay_1-2 + Delay_2-B&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RTT = round-trip-time&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;real-internet-delays-and-routes&quot;&gt;Real internet delays and routes&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;What do “real” internet delay and loss look like?&lt;/li&gt;
  &lt;li&gt;traceroute program: provides delay measurement from source to router along end-end Internet path towards destination. For all i:
    &lt;ul&gt;
      &lt;li&gt;Sends three packets that will reach router i on path towards destination&lt;/li&gt;
      &lt;li&gt;Router i will return packets to sender&lt;/li&gt;
      &lt;li&gt;Sender times interval between transmission and reply&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RTT =/= 2 * Oneway Delay traceroute
    &lt;ul&gt;
      &lt;li&gt;Paths are not necessarily symmetric&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-we-have-covered-today&quot;&gt;What we have covered today&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Internet: made of huge number of hosts, routers, wired and wireless links&lt;/li&gt;
  &lt;li&gt;Hosts: run bunch of protocols to exchange data with each other&lt;/li&gt;
  &lt;li&gt;Routers: run bunch of protocols in order to be able to move data to right destinations&lt;/li&gt;
  &lt;li&gt;Why protocols are layered&lt;/li&gt;
  &lt;li&gt;How to calculate packet delays as they move across a network&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 29 Mar 2016 22:26:00 -0700</pubDate>
        <link>http://jacobnisnevich.github.io/cs118-notes/2016/03/29/lecture_1.html</link>
        <guid isPermaLink="true">http://jacobnisnevich.github.io/cs118-notes/2016/03/29/lecture_1.html</guid>
        
        
      </item>
    
  </channel>
</rss>
